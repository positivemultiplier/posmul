/**
 * Supabase MoneyWave History Repository Implementation
 *
 * MoneyWave 1-2-3 시스템의 실행 이력 및 효과성 분석을 위한 Repository 구현체
 * IMoneyWaveHistoryRepository 인터페이스를 Supabase로 구현
 */

import { UserId } from "../../../../shared/types/branded-types";
import { Result } from "../../../../shared/types/common";
import {
  IMoneyWaveHistoryRepository,
  MoneyWave1Record,
  MoneyWave2Record,
  MoneyWave3Record,
  MoneyWaveEffectiveness,
  MoneyWaveStatistics,
} from "../../domain/repositories/money-wave-history.repository";
import {
  createEBIT,
  createPMC,
  unwrapEBIT,
  unwrapPMC,
} from "../../domain/value-objects";
import { BaseSupabaseRepository } from "./base-supabase.repository";

/**
 * Supabase 기반 MoneyWave History Repository 구현
 */
export class SupabaseMoneyWaveHistoryRepository
  extends BaseSupabaseRepository
  implements IMoneyWaveHistoryRepository
{
  /**
   * MoneyWave1 실행 기록 저장
   */
  async saveMoneyWave1Record(
    record: Omit<MoneyWave1Record, "recordId">
  ): Promise<Result<MoneyWave1Record>> {
    try {
      const { data, error } = await this.client
        .from("money_wave_events")
        .insert({
          wave_type: "WAVE1",
          event_data: {
            companyId: record.companyId,
            executionDate: record.executionDate.toISOString(),
            ebitAmount: unwrapEBIT(record.ebitAmount),
            pmcIssued: unwrapPMC(record.pmcIssued),
            conversionRate: record.conversionRate,
            stakeholderCount: record.stakeholderCount,
            economicImpact: record.economicImpact,
            socialWelfare: record.socialWelfare,
          },
          processed_at: new Date().toISOString(),
        })
        .select()
        .single();

      if (error) {
        return this.handleError(error);
      }

      const savedRecord: MoneyWave1Record = {
        recordId: data.id,
        companyId: data.event_data.companyId,
        executionDate: new Date(data.event_data.executionDate),
        ebitAmount: createEBIT(data.event_data.ebitAmount),
        pmcIssued: createPMC(data.event_data.pmcIssued),
        conversionRate: data.event_data.conversionRate,
        stakeholderCount: data.event_data.stakeholderCount,
        economicImpact: data.event_data.economicImpact,
        socialWelfare: data.event_data.socialWelfare,
      };

      return this.handleSuccess(savedRecord);
    } catch (error) {
      return this.handleError(error);
    }
  }

  /**
   * MoneyWave2 실행 기록 저장
   */
  async saveMoneyWave2Record(
    record: Omit<MoneyWave2Record, "recordId">
  ): Promise<Result<MoneyWave2Record>> {
    try {
      const { data, error } = await this.client
        .from("money_wave_events")
        .insert({
          wave_type: "WAVE2",
          event_data: {
            executionDate: record.executionDate.toISOString(),
            eligibilitySnapshot: record.eligibilitySnapshot,
            redistributionResults: record.redistributionResults,
            pigouEfficiency: record.pigouEfficiency,
            rawlsianJustice: record.rawlsianJustice,
          },
          processed_at: new Date().toISOString(),
        })
        .select()
        .single();

      if (error) {
        return this.handleError(error);
      }

      const savedRecord: MoneyWave2Record = {
        recordId: data.id,
        executionDate: new Date(data.event_data.executionDate),
        eligibilitySnapshot: data.event_data.eligibilitySnapshot,
        redistributionResults: data.event_data.redistributionResults,
        pigouEfficiency: data.event_data.pigouEfficiency,
        rawlsianJustice: data.event_data.rawlsianJustice,
      };

      return this.handleSuccess(savedRecord);
    } catch (error) {
      return this.handleError(error);
    }
  }

  /**
   * MoneyWave3 실행 기록 저장
   */
  async saveMoneyWave3Record(
    record: Omit<MoneyWave3Record, "recordId">
  ): Promise<Result<MoneyWave3Record>> {
    try {
      const { data, error } = await this.client
        .from("money_wave_events")
        .insert({
          wave_type: "WAVE3",
          event_data: {
            executionDate: record.executionDate.toISOString(),
            entrepreneurialActivity: record.entrepreneurialActivity,
            resourceAllocation: record.resourceAllocation,
            schumpeterianImpact: record.schumpeterianImpact,
            kirznerianDiscovery: record.kirznerianDiscovery,
          },
          processed_at: new Date().toISOString(),
        })
        .select()
        .single();

      if (error) {
        return this.handleError(error);
      }

      const savedRecord: MoneyWave3Record = {
        recordId: data.id,
        executionDate: new Date(data.event_data.executionDate),
        entrepreneurialActivity: data.event_data.entrepreneurialActivity,
        resourceAllocation: data.event_data.resourceAllocation,
        schumpeterianImpact: data.event_data.schumpeterianImpact,
        kirznerianDiscovery: data.event_data.kirznerianDiscovery,
      };

      return this.handleSuccess(savedRecord);
    } catch (error) {
      return this.handleError(error);
    }
  }

  /**
   * MoneyWave1 기록 조회
   */
  async getMoneyWave1Records(
    limit?: number,
    offset?: number
  ): Promise<Result<MoneyWave1Record[]>> {
    try {
      let query = this.client
        .from("money_wave_events")
        .select("*")
        .eq("wave_type", "WAVE1")
        .order("processed_at", { ascending: false });

      if (limit) {
        query = query.limit(limit);
      }

      if (offset) {
        query = query.range(offset, offset + (limit || 100) - 1);
      }

      const { data, error } = await query;

      if (error) {
        return this.handleError(error);
      }

      const records: MoneyWave1Record[] = data.map((row) => ({
        id: row.id as MoneyWaveId,
        triggeredBy: row.triggered_by as UserId,
        ebitAmount: createEBIT(row.ebit_amount),
        pmcIssued: createPMC(row.pmc_issued),
        agencyScore: row.agency_score,
        informationAsymmetryReduction: row.information_asymmetry_reduction,
        companyId: row.event_data.companyId,
        validationStatus: row.event_data.validationStatus,
        agencyTheoryEffectiveness: row.event_data.agencyTheoryEffectiveness,
        createdAt: new Date(row.processed_at),
      }));

      return this.handleSuccess(records);
    } catch (error) {
      return this.handleError(error);
    }
  }

  /**
   * MoneyWave2 기록 조회
   */
  async getMoneyWave2Records(
    limit?: number,
    offset?: number
  ): Promise<Result<MoneyWave2Record[]>> {
    try {
      let query = this.client
        .from("money_wave_events")
        .select("*")
        .eq("wave_type", "WAVE2")
        .order("processed_at", { ascending: false });

      if (limit) {
        query = query.limit(limit);
      }

      if (offset) {
        query = query.range(offset, offset + (limit || 100) - 1);
      }

      const { data, error } = await query;

      if (error) {
        return this.handleError(error);
      }

      const records: MoneyWave2Record[] = data.map((row) => ({
        id: row.id as MoneyWaveId,
        triggeredBy: row.triggered_by as UserId,
        redistributionAmount: createPMC(row.redistribution_amount),
        efficiencyScore: row.efficiency_score,
        eligibleUsers: row.event_data.eligibleUsers,
        redistributionCriteria: row.event_data.redistributionCriteria,
        pigouEffectiveness: row.event_data.pigouEffectiveness,
        rawlsJusticeIndex: row.event_data.rawlsJusticeIndex,
        createdAt: new Date(row.processed_at),
      }));

      return this.handleSuccess(records);
    } catch (error) {
      return this.handleError(error);
    }
  }

  /**
   * MoneyWave3 기록 조회
   */
  async getMoneyWave3Records(
    limit?: number,
    offset?: number
  ): Promise<Result<MoneyWave3Record[]>> {
    try {
      let query = this.client
        .from("money_wave_events")
        .select("*")
        .eq("wave_type", "WAVE3")
        .order("processed_at", { ascending: false });

      if (limit) {
        query = query.limit(limit);
      }

      if (offset) {
        query = query.range(offset, offset + (limit || 100) - 1);
      }

      const { data, error } = await query;

      if (error) {
        return this.handleError(error);
      }

      const records: MoneyWave3Record[] = data.map((row) => ({
        id: row.id as MoneyWaveId,
        triggeredBy: row.triggered_by as UserId,
        innovationMultiplier: row.innovation_multiplier,
        entrepreneurId: row.event_data.entrepreneurId,
        projectId: row.event_data.projectId,
        investmentAmount: createPMC(row.event_data.investmentAmount),
        riskAssessment: row.event_data.riskAssessment,
        schumpeterIndex: row.event_data.schumpeterIndex,
        kirznerOpportunityScore: row.event_data.kirznerOpportunityScore,
        createdAt: new Date(row.processed_at),
      }));

      return this.handleSuccess(records);
    } catch (error) {
      return this.handleError(error);
    }
  }

  /**
   * MoneyWave 효과성 분석
   */
  async analyzeMoneyWaveEffectiveness(
    waveType: "WAVE1" | "WAVE2" | "WAVE3",
    startDate: Date,
    endDate: Date
  ): Promise<Result<MoneyWaveEffectiveness>> {
    try {
      const { data, error } = await this.client
        .from("money_wave_events")
        .select("*")
        .eq("wave_type", waveType)
        .gte("processed_at", startDate.toISOString())
        .lte("processed_at", endDate.toISOString())
        .order("processed_at", { ascending: true });

      if (error) {
        return this.handleError(error);
      }

      // 효과성 지표 계산
      const totalEvents = data.length;
      let totalPMCImpact = 0;
      let averageEffectiveness = 0;

      switch (waveType) {
        case "WAVE1":
          totalPMCImpact = data.reduce(
            (sum, row) => sum + (row.pmc_issued || 0),
            0
          );
          averageEffectiveness =
            data.reduce((sum, row) => sum + (row.agency_score || 0), 0) /
            totalEvents;
          break;
        case "WAVE2":
          totalPMCImpact = data.reduce(
            (sum, row) => sum + (row.redistribution_amount || 0),
            0
          );
          averageEffectiveness =
            data.reduce((sum, row) => sum + (row.efficiency_score || 0), 0) /
            totalEvents;
          break;
        case "WAVE3":
          totalPMCImpact = data.reduce(
            (sum, row) => sum + (row.event_data?.investmentAmount || 0),
            0
          );
          averageEffectiveness =
            data.reduce(
              (sum, row) => sum + (row.innovation_multiplier || 0),
              0
            ) / totalEvents;
          break;
      }

      const effectiveness: MoneyWaveEffectiveness = {
        waveType,
        periodStart: startDate,
        periodEnd: endDate,
        totalEvents,
        totalPMCImpact: createPMC(totalPMCImpact),
        averageEffectiveness,
        macroeconomicImpact: {
          gdpGrowthEffect: 0, // 실제 계산 로직 필요
          inflationEffect: 0,
          unemploymentEffect: 0,
          giniCoefficientChange: 0,
        },
        microeconomicImpact: {
          consumerSurplusChange: 0,
          producerSurplusChange: 0,
          marketEfficiencyImprovement: 0,
          competitionIndexChange: 0,
        },
        institutionalImprovement: {
          transparencyIndex: 0,
          participationRate: 0,
          corruptionReductionIndex: 0,
          democraticLegitimacy: 0,
        },
      };

      return this.handleSuccess(effectiveness);
    } catch (error) {
      return this.handleError(error);
    }
  }

  /**
   * MoneyWave 실행 통계
   */
  async getMoneyWaveStatistics(
    period: "daily" | "weekly" | "monthly"
  ): Promise<Result<MoneyWaveStatistics>> {
    try {
      // 기간별 집계 로직
      let dateFormat: string;
      let intervalStr: string;

      switch (period) {
        case "daily":
          dateFormat = "YYYY-MM-DD";
          intervalStr = "1 day";
          break;
        case "weekly":
          dateFormat = 'YYYY-"W"WW';
          intervalStr = "1 week";
          break;
        case "monthly":
          dateFormat = "YYYY-MM";
          intervalStr = "1 month";
          break;
      }

      const { data, error } = await this.client.rpc(
        "get_moneywave_statistics",
        {
          period_format: dateFormat,
          interval_str: intervalStr,
        }
      );

      if (error) {
        return this.handleError(error);
      }

      const statistics: MoneyWaveStatistics = {
        period,
        wave1ExecutionCount: data?.wave1_count || 0,
        wave2ExecutionCount: data?.wave2_count || 0,
        wave3ExecutionCount: data?.wave3_count || 0,
        totalPMCEmitted: createPMC(data?.total_pmc_emitted || 0),
        totalPMCRedistributed: createPMC(data?.total_pmc_redistributed || 0),
        totalInvestmentValue: createPMC(data?.total_investment_value || 0),
        averageExecutionFrequency: data?.avg_frequency || 0,
        longTermTrendAnalysis: {
          growthRate: data?.growth_rate || 0,
          seasonalityIndex: data?.seasonality_index || 0,
          volatilityMeasure: data?.volatility || 0,
        },
      };

      return this.handleSuccess(statistics);
    } catch (error) {
      return this.handleError(error);
    }
  }

  /**
   * 사용자별 MoneyWave 참여 이력 조회
   */
  async getUserMoneyWaveHistory(
    userId: UserId
  ): Promise<
    Result<Array<MoneyWave1Record | MoneyWave2Record | MoneyWave3Record>>
  > {
    try {
      const { data, error } = await this.client
        .from("money_wave_events")
        .select("*")
        .eq("triggered_by", userId)
        .order("processed_at", { ascending: false });

      if (error) {
        return this.handleError(error);
      }

      const history: Array<
        MoneyWave1Record | MoneyWave2Record | MoneyWave3Record
      > = data.map((row) => {
        const baseFields = {
          id: row.id as MoneyWaveId,
          triggeredBy: row.triggered_by as UserId,
          createdAt: new Date(row.processed_at),
        };

        switch (row.wave_type) {
          case "WAVE1":
            return {
              ...baseFields,
              ebitAmount: createEBIT(row.ebit_amount),
              pmcIssued: createPMC(row.pmc_issued),
              agencyScore: row.agency_score,
              informationAsymmetryReduction:
                row.information_asymmetry_reduction,
              companyId: row.event_data.companyId,
              validationStatus: row.event_data.validationStatus,
              agencyTheoryEffectiveness:
                row.event_data.agencyTheoryEffectiveness,
            } as MoneyWave1Record;

          case "WAVE2":
            return {
              ...baseFields,
              redistributionAmount: createPMC(row.redistribution_amount),
              efficiencyScore: row.efficiency_score,
              eligibleUsers: row.event_data.eligibleUsers,
              redistributionCriteria: row.event_data.redistributionCriteria,
              pigouEffectiveness: row.event_data.pigouEffectiveness,
              rawlsJusticeIndex: row.event_data.rawlsJusticeIndex,
            } as MoneyWave2Record;

          case "WAVE3":
            return {
              ...baseFields,
              innovationMultiplier: row.innovation_multiplier,
              entrepreneurId: row.event_data.entrepreneurId,
              projectId: row.event_data.projectId,
              investmentAmount: createPMC(row.event_data.investmentAmount),
              riskAssessment: row.event_data.riskAssessment,
              schumpeterIndex: row.event_data.schumpeterIndex,
              kirznerOpportunityScore: row.event_data.kirznerOpportunityScore,
            } as MoneyWave3Record;

          default:
            throw new Error(`Unknown wave type: ${row.wave_type}`);
        }
      });

      return this.handleSuccess(history);
    } catch (error) {
      return this.handleError(error);
    }
  }

  /**
   * 상관관계 분석
   */
  async getCorrelationAnalysis(): Promise<
    Result<{
      wave1ToGDPCorrelation: number;
      wave2ToGiniCorrelation: number;
      wave3ToInnovationCorrelation: number;
      crossWaveCorrelations: Array<{
        wave1: string;
        wave2: string;
        correlation: number;
      }>;
    }>
  > {
    try {
      // 실제 구현에서는 복잡한 통계 분석이 필요
      // 여기서는 기본 구조만 제공
      const correlations = {
        wave1ToGDPCorrelation: 0.0,
        wave2ToGiniCorrelation: 0.0,
        wave3ToInnovationCorrelation: 0.0,
        crossWaveCorrelations: [
          { wave1: "WAVE1", wave2: "WAVE2", correlation: 0.0 },
          { wave1: "WAVE1", wave2: "WAVE3", correlation: 0.0 },
          { wave1: "WAVE2", wave2: "WAVE3", correlation: 0.0 },
        ],
      };

      return this.handleSuccess(correlations);
    } catch (error) {
      return this.handleError(error);
    }
  }
}
