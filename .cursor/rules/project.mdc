---
description: 
globs: 
alwaysApply: true
---
# PosMul Prediction Game - Cursor Rules (Dual MCP Edition)

You are an expert in TypeScript, Next.js 15 App Router, Domain-Driven Design (DDD), Clean Architecture, **Supabase MCP Integration**, and **GitHub MCP Integration**.

## Project Context

This is PosMul, an AI-era direct democracy platform providing prediction games and local economy integration. The platform implements Agency Theory, CAPM, and behavioral economics theories through code.

**CRITICAL**: This project has a **tightly coupled economy system (PMP/PMC)** that spans across all domains. Use **Shared Kernel** and **Domain Events** patterns for economic integration.

**DEVELOPMENT APPROACH**: We use **dual MCP (Model Context Protocol)** approach:
- **Supabase MCP** for all database operations (NOT Supabase CLI)
- **GitHub MCP** for all project management operations (NOT GitHub CLI)
All database changes, queries, issue management, and code collaboration should go through MCP tools.

## Development Environment

- **OS**: Windows
- **Shell**: PowerShell (always use PowerShell commands)
- **Path Format**: Windows backslash paths (e.g., `src\bounded-contexts\`)
- **Commands**: Use semicolon (`;`) instead of `&&` for command chaining
- **Database**: Supabase via MCP tools (mcp_supabase_*)
- **Project Management**: GitHub via MCP tools (mcp_Github_*)

## Core Architecture Principles

### DDD + Clean Architecture with Economic Integration

- **Shared Kernel**: Economy domain (PMP/PMC) is shared across all contexts
- **Domain Events**: Use events for cross-domain communication
- **Anti-Corruption Layer**: Protect domain integrity while allowing integration
- Domain layer has NO external dependencies (pure business logic)
- Use Aggregate, Entity, Value Object, Domain Service appropriately
- Repository pattern for data access abstraction

### Dependency Rules (CRITICAL)

```
Presentation ‚Üí Application ‚Üí Domain
Infrastructure ‚Üí Domain (implements interfaces)
Shared Economy Kernel ‚Üê All Domains (read-only access)
```

- Domain NEVER depends on external layers
- Application only depends on Domain + Shared Economy Kernel
- Infrastructure implements Domain interfaces
- **All domains can READ from Economy Kernel, but WRITE through Domain Events**

## MCP Integration Rules (CRITICAL)

### Supabase MCP - Database Operations

- **NEVER use Supabase CLI** for schema changes
- **ALWAYS use `mcp_supabase_apply_migration`** for DDL operations
- **Use `mcp_supabase_execute_sql`** for data queries and DML
- **Use `mcp_supabase_list_tables`** to inspect schema
- **Use `mcp_supabase_get_advisors`** for security and performance checks

### GitHub MCP - Project Management

- **NEVER use GitHub CLI** for project operations
- **ALWAYS use `mcp_Github_create_issue`** for task management
- **Use `mcp_Github_create_pull_request`** for code reviews
- **Use `mcp_Github_get_file_contents`** for file inspection
- **Use `mcp_Github_create_or_update_file`** for file management

### Migration Pattern with MCP

```typescript
// 1. Create migration using MCP
await mcp_supabase_apply_migration({
  project_id: "your-project-id",
  name: "create_prediction_tables",
  query: `
    CREATE TABLE prediction_games (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      creator_id UUID NOT NULL,
      title TEXT NOT NULL,
      -- ... other fields
    );
  `,
});

// 2. Verify with advisors
await mcp_supabase_get_advisors({
  project_id: "your-project-id",
  type: "security",
});
```

### Repository Implementation with MCP

```typescript
export class SupabasePredictionGameRepository
  implements IPredictionGameRepository
{
  constructor(private readonly projectId: string) {}

  async save(game: PredictionGame): Promise<Result<void, RepositoryError>> {
    try {
      const query = `
        INSERT INTO prediction_games (id, creator_id, title, ...)
        VALUES ($1, $2, $3, ...)
        ON CONFLICT (id) DO UPDATE SET ...
      `;

      await mcp_supabase_execute_sql({
        project_id: this.projectId,
        query: query,
      });

      return success(undefined);
    } catch (error) {
      return failure(new RepositoryError("Save failed", error));
    }
  }
}
```

### Economic Integration with MCP

```sql
-- Economic tables (shared) - Apply via MCP
CREATE TABLE pmp_accounts (
  user_id UUID PRIMARY KEY,
  balance DECIMAL(15,2) NOT NULL DEFAULT 0,
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE pmc_accounts (
  user_id UUID PRIMARY KEY,
  balance DECIMAL(15,2) NOT NULL DEFAULT 0,
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE economic_transactions (
  id UUID PRIMARY KEY,
  user_id UUID NOT NULL,
  transaction_type TEXT NOT NULL, -- 'pmp_earned', 'pmp_spent', 'pmc_earned', 'pmc_spent'
  amount DECIMAL(15,2) NOT NULL,
  source_domain TEXT NOT NULL, -- 'prediction', 'investment', 'forum', 'donation'
  source_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

## Economic System Integration Patterns

### 1. Shared Kernel Pattern (Economy Domain)

```typescript
// src/shared/economy-kernel/
export interface PmpAccount {
  userId: UserId;
  balance: number;
  readonly transactions: PmpTransaction[];
}

export interface PmcAccount {
  userId: UserId;
  balance: number;
  readonly transactions: PmcTransaction[];
}

export class EconomyKernel {
  constructor(private readonly projectId: string) {}

  // Read-only access for all domains
  async getPmpBalance(userId: UserId): Promise<number> {
    const result = await mcp_supabase_execute_sql({
      project_id: this.projectId,
      query: "SELECT balance FROM pmp_accounts WHERE user_id = $1",
    });
    return result.data?.[0]?.balance || 0;
  }

  async getPmcBalance(userId: UserId): Promise<number> {
    const result = await mcp_supabase_execute_sql({
      project_id: this.projectId,
      query: "SELECT balance FROM pmc_accounts WHERE user_id = $1",
    });
    return result.data?.[0]?.balance || 0;
  }

  // Write operations through domain events only
  private constructor() {} // Prevent direct instantiation
}
```

### 2. Domain Events for Economic Transactions

```typescript
// Cross-domain economic events
export class PmpEarnedEvent implements DomainEvent {
  constructor(
    public readonly userId: UserId,
    public readonly amount: number,
    public readonly source: "major-league" | "brainstorming" | "debate",
    public readonly sourceId: string,
    public readonly occurredAt: Date = new Date()
  ) {}
}

export class PmcEarnedEvent implements DomainEvent {
  constructor(
    public readonly userId: UserId,
    public readonly amount: number,
    public readonly source:
      | "local-league"
      | "cloud-funding"
      | "prediction-success"
      | "gift-aid",
    public readonly sourceId: string,
    public readonly occurredAt: Date = new Date()
  ) {}
}

export class PmpSpentEvent implements DomainEvent {
  constructor(
    public readonly userId: UserId,
    public readonly amount: number,
    public readonly purpose: "prediction-participation",
    public readonly targetId: string,
    public readonly occurredAt: Date = new Date()
  ) {}
}
```

### 3. Anti-Corruption Layer for Economic Integration

```typescript
// Each domain has its own economic service
export class PredictionEconomicService {
  constructor(
    private readonly economyKernel: EconomyKernel,
    private readonly eventPublisher: IDomainEventPublisher
  ) {}

  async canParticipateInPrediction(
    userId: UserId,
    requiredPmp: number
  ): Promise<boolean> {
    const balance = await this.economyKernel.getPmpBalance(userId);
    return balance >= requiredPmp;
  }

  async participateInPrediction(
    userId: UserId,
    predictionId: PredictionId,
    pmpAmount: number
  ): Promise<Result<void, EconomicError>> {
    // Publish event instead of direct modification
    await this.eventPublisher.publish(
      new PmpSpentEvent(
        userId,
        pmpAmount,
        "prediction-participation",
        predictionId
      )
    );
    return { success: true, data: undefined };
  }
}
```

## File Structure Rules (Updated for MCP Integration)

```
src\
  shared\
    economy-kernel\          # Shared economic domain
      entities\
        pmp-account.entity.ts
        pmc-account.entity.ts
        money-wave.entity.ts
      value-objects\
        economic-types.ts
      services\
        economy-kernel.service.ts
      events\
        economic-events.ts
    events\                  # Cross-domain event system
      domain-events.ts
      event-publisher.ts
    mcp\                     # MCP integration utilities
      supabase-client.ts
      migration-helpers.ts
  bounded-contexts\
    [context-name]\
      domain\
        entities\
        value-objects\
        repositories\
        services\
          [context]-economic.service.ts  # Economic integration per domain
        events\
      application\
        use-cases\
        services\
        dto\
        event-handlers\      # Handle economic events
      infrastructure\
        repositories\        # MCP-based implementations
        external-services\
        event-handlers\      # Infrastructure event handlers
      presentation\
        components\
        hooks\
      context.md
```

## MCP-Specific Development Patterns

### Database Schema Creation

```typescript
// Use MCP for all schema operations
const createPredictionTables = async (projectId: string) => {
  await mcp_supabase_apply_migration({
    project_id: projectId,
    name: "create_prediction_tables",
    query: `
      CREATE TABLE prediction_games (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        creator_id UUID NOT NULL,
        title TEXT NOT NULL,
        description TEXT,
        prediction_type TEXT NOT NULL,
        options JSONB NOT NULL,
        start_time TIMESTAMPTZ NOT NULL,
        end_time TIMESTAMPTZ NOT NULL,
        settlement_time TIMESTAMPTZ NOT NULL,
        minimum_stake DECIMAL(15,2) NOT NULL DEFAULT 0,
        maximum_stake DECIMAL(15,2) NOT NULL DEFAULT 1000,
        max_participants INTEGER,
        status TEXT NOT NULL DEFAULT 'PENDING',
        money_wave_id UUID,
        game_importance_score DECIMAL(3,2) DEFAULT 1.0,
        allocated_prize_pool DECIMAL(15,2) DEFAULT 0,
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW(),
        version INTEGER DEFAULT 1,
        
        CONSTRAINT valid_status CHECK (status IN ('PENDING', 'ACTIVE', 'ENDED', 'SETTLED', 'CANCELLED', 'DELETED')),
        CONSTRAINT valid_prediction_type CHECK (prediction_type IN ('binary', 'wdl', 'ranking')),
        CONSTRAINT positive_stakes CHECK (minimum_stake >= 0 AND maximum_stake > minimum_stake),
        CONSTRAINT valid_importance CHECK (game_importance_score BETWEEN 0.1 AND 3.0),
        CONSTRAINT valid_times CHECK (start_time < end_time AND end_time < settlement_time)
      );

      -- Create indexes
      CREATE INDEX idx_prediction_games_creator ON prediction_games(creator_id);
      CREATE INDEX idx_prediction_games_status ON prediction_games(status);
      CREATE INDEX idx_prediction_games_start_time ON prediction_games(start_time);
      CREATE INDEX idx_prediction_games_money_wave ON prediction_games(money_wave_id);

      -- Enable RLS
      ALTER TABLE prediction_games ENABLE ROW LEVEL SECURITY;

      -- RLS Policies
      CREATE POLICY "Users can view all games" ON prediction_games
        FOR SELECT USING (true);

      CREATE POLICY "Users can create games" ON prediction_games
        FOR INSERT WITH CHECK (auth.uid() = creator_id);

      CREATE POLICY "Creators can update their games" ON prediction_games
        FOR UPDATE USING (auth.uid() = creator_id);
    `,
  });
};
```

### Data Queries with MCP

```typescript
// Repository implementation using MCP
export class MCPPredictionGameRepository implements IPredictionGameRepository {
  constructor(private readonly projectId: string) {}

  async findByStatus(
    status: GameStatus
  ): Promise<Result<PredictionGame[], RepositoryError>> {
    try {
      const result = await mcp_supabase_execute_sql({
        project_id: this.projectId,
        query: `
          SELECT pg.*, 
                 COUNT(p.id) as participant_count,
                 SUM(p.stake) as total_stake
          FROM prediction_games pg
          LEFT JOIN predictions p ON pg.id = p.game_id
          WHERE pg.status = $1
          GROUP BY pg.id
          ORDER BY pg.created_at DESC
        `,
        // Note: MCP might handle parameters differently
      });

      const games = result.data.map((row) => this.mapDatabaseToDomain(row));
      return success(games);
    } catch (error) {
      return failure(new RepositoryError("Query failed", error));
    }
  }
}
```

### Security and Performance Monitoring

```typescript
// Regular security checks using MCP
const checkDatabaseSecurity = async (projectId: string) => {
  const securityAdvisors = await mcp_supabase_get_advisors({
    project_id: projectId,
    type: "security",
  });

  const performanceAdvisors = await mcp_supabase_get_advisors({
    project_id: projectId,
    type: "performance",
  });

  // Log or handle advisor recommendations
  console.log("Security recommendations:", securityAdvisors);
  console.log("Performance recommendations:", performanceAdvisors);
};
```

## TypeScript Standards (Updated for MCP)

- Use strict TypeScript configuration
- Prefer `interface` over `type` for object shapes
- Use branded types for domain identifiers:

```typescript
type UserId = string & { readonly brand: unique symbol };
type PredictionId = string & { readonly brand: unique symbol };
type PmpAmount = number & { readonly brand: unique symbol };
type PmcAmount = number & { readonly brand: unique symbol };
type SupabaseProjectId = string & { readonly brand: unique symbol };
```

- Implement Result/Either pattern for error handling:

```typescript
type Result<T, E = Error> =
  | { success: true; data: T }
  | { success: false; error: E };
```

## Naming Conventions

### Files & Directories

- Files: `kebab-case` ‚Üí `prediction-game.entity.ts`
- Classes: `PascalCase` ‚Üí `PredictionGame`
- Functions/Variables: `camelCase` ‚Üí `createPredictionGame`
- Constants: `SCREAMING_SNAKE_CASE` ‚Üí `MAX_PREDICTIONS_PER_GAME`

### Domain Objects

- Entities: `PredictionGame`, `User`, `Market`
- Value Objects: `PredictionId`, `UserId`, `Email`
- Repositories: `IPredictionGameRepository` (interface), `MCPPredictionGameRepository` (impl)
- Services: `PredictionScoringService`, `MarketDataService`
- Economic Services: `PredictionEconomicService`, `InvestmentEconomicService`

### React Components

- Components: `PredictionCard`, `GameList`, `UserDashboard`
- Hooks: `usePredictionGame`, `useMarketData`, `useEconomicBalance`
- Pages: `page.tsx`, `layout.tsx`

## Code Generation Rules

### When Creating Domain Entities with Economic Integration

```typescript
export class PredictionGame {
  private constructor(
    private readonly id: PredictionGameId,
    private readonly title: string,
    private status: GameStatus,
    private predictions: Prediction[]
  ) {}

  public static create(title: string): Result<PredictionGame, ValidationError> {
    // Domain validation logic
  }

  public addPrediction(
    prediction: Prediction,
    economicService: PredictionEconomicService
  ): Result<void, BusinessRuleError> {
    // Business logic with economic validation
  }
}
```

### When Creating Repository Interfaces

```typescript
// Domain layer - NO implementation details
export interface IPredictionGameRepository {
  save(game: PredictionGame): Promise<Result<void, RepositoryError>>;
  findById(
    id: PredictionGameId
  ): Promise<Result<PredictionGame | null, RepositoryError>>;
  findByStatus(
    status: GameStatus
  ): Promise<Result<PredictionGame[], RepositoryError>>;
}
```

### When Creating Use Cases with Economic Integration

```typescript
// Application layer - orchestrates domain objects + economic kernel
export class CreatePredictionGameUseCase {
  constructor(
    private readonly repository: IPredictionGameRepository,
    private readonly eventPublisher: IDomainEventPublisher,
    private readonly economicService: PredictionEconomicService
  ) {}

  async execute(
    request: CreateGameRequest
  ): Promise<Result<CreateGameResponse, UseCaseError>> {
    // 1. Validate input
    // 2. Check economic prerequisites
    // 3. Create domain object
    // 4. Save via repository (using MCP)
    // 5. Publish domain events (including economic events)
    // 6. Return response
  }
}
```

### When Creating React Components with Economic Data

- Default to Server Components
- Use Client Components only when needed (interactivity, browser APIs)
- Implement proper loading states with Suspense
- Include error boundaries
- **Always display economic balance (PMP/PMC) in relevant components**

```typescript
// Server Component with economic data
export default async function GameList({ userId }: { userId: UserId }) {
  const [games, pmpBalance, pmcBalance] = await Promise.all([
    getGames(),
    getPmpBalance(userId),
    getPmcBalance(userId),
  ]);

  return (
    <div>
      <EconomicBalance pmp={pmpBalance} pmc={pmcBalance} />
      {/* Game list JSX */}
    </div>
  );
}

// Client Component (when needed)
("use client");
export function PredictionForm({ userId }: { userId: UserId }) {
  const { pmpBalance } = useEconomicBalance(userId);
  // Interactive form logic with economic validation
}
```

## MCP Integration Best Practices

### Project ID Management

```typescript
// Create a centralized project ID service
export class SupabaseProjectService {
  private static instance: SupabaseProjectService;
  private projectId: SupabaseProjectId;

  private constructor() {
    this.projectId = process.env.SUPABASE_PROJECT_ID as SupabaseProjectId;
    if (!this.projectId) {
      throw new Error("SUPABASE_PROJECT_ID environment variable is required");
    }
  }

  static getInstance(): SupabaseProjectService {
    if (!SupabaseProjectService.instance) {
      SupabaseProjectService.instance = new SupabaseProjectService();
    }
    return SupabaseProjectService.instance;
  }

  getProjectId(): SupabaseProjectId {
    return this.projectId;
  }
}
```

### Error Handling for MCP

```typescript
export class MCPError extends Error {
  constructor(message: string, public operation: string, public cause?: Error) {
    super(message);
    this.name = "MCPError";
  }
}

export const handleMCPError = (error: unknown, operation: string): MCPError => {
  if (error instanceof Error) {
    return new MCPError(
      `MCP ${operation} failed: ${error.message}`,
      operation,
      error
    );
  }
  return new MCPError(`MCP ${operation} failed with unknown error`, operation);
};
```

## Error Handling Patterns

### Domain Errors

```typescript
export class ValidationError extends Error {
  constructor(message: string, public field: string) {
    super(message);
    this.name = "ValidationError";
  }
}

export class BusinessRuleError extends Error {
  constructor(message: string, public rule: string) {
    super(message);
    this.name = "BusinessRuleError";
  }
}

export class EconomicError extends Error {
  constructor(
    message: string,
    public economicType:
      | "insufficient-pmp"
      | "insufficient-pmc"
      | "invalid-transaction"
  ) {
    super(message);
    this.name = "EconomicError";
  }
}
```

### Application Errors

```typescript
export class UseCaseError extends Error {
  constructor(message: string, public cause?: Error) {
    super(message);
    this.name = "UseCaseError";
  }
}
```

## Next.js 15 App Router Rules

- Use App Router file conventions
- Implement loading.tsx, error.tsx, not-found.tsx
- Leverage Server Actions for mutations
- Use proper caching strategies
- **Always include economic data in page props**

```typescript
// app/predictions/loading.tsx
export default function Loading() {
  return <PredictionsSkeleton />;
}

// app/predictions/error.tsx
("use client");
export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  return <ErrorBoundary error={error} reset={reset} />;
}
```

## PowerShell Commands (ALWAYS USE)

```powershell
# Development
npm run dev
npm test
npm run build

# Multiple commands (use semicolon)
cd src; npm install; npm run dev

# File operations
New-Item -ItemType Directory -Path "src\bounded-contexts\prediction"
```

## Performance & Security

### Performance

- Use React.memo for expensive components
- Implement proper database indexing via MCP migrations
- Use dynamic imports for code splitting
- Implement caching strategies
- **Cache economic balance data with proper invalidation**

### Security

- Validate all inputs at API boundaries
- Use Supabase RLS via MCP migrations
- Store sensitive data in environment variables
- Follow OWASP security guidelines
- **Implement economic transaction validation and audit trails**
- **Regularly run `mcp_supabase_get_advisors` for security checks**

## Domain-Specific Rules for PosMul

### Economy Domain (Shared Kernel)

- PMP (risk-free asset) and PMC (risky asset) are core value objects
- MoneyWave system handles PMC distribution
- Agency Theory implementation is the core differentiator
- **All economic operations must go through domain events**
- **Never allow direct balance modification outside economy domain**

### Prediction Domain

- PredictionGame is the main aggregate
- Prediction is an entity within the aggregate
- Game lifecycle: Created ‚Üí Active ‚Üí Ended ‚Üí Settled
- **Always check PMP balance before allowing participation**
- **Emit PmcEarnedEvent on successful predictions**

### Investment Domain

- Local League, Major League, Cloud Funding are separate aggregates
- Each has different point earning mechanisms
- **Major League earns PMP, Local League earns PMC**
- **Cloud Funding earns PMC**

### Forum Domain

- **Debate and Brainstorming earn PMP**
- **Quality contributions should be rewarded with economic incentives**

### Donation Domain

- **Uses PMC for donations**
- **Implements Money Wave redistribution logic**

## CRITICAL REMINDERS

1. **NEVER violate Clean Architecture dependency rules**
2. **Domain layer must be pure** - no external dependencies
3. **Use PowerShell commands** - never bash/zsh
4. **Always implement Result pattern** for error handling
5. **Repository interfaces in Domain** - implementations in Infrastructure
6. **Server Components by default** - Client only when needed
7. **Proper error boundaries** and loading states
8. **üî• USE MCP TOOLS FOR ALL DATABASE AND PROJECT OPERATIONS** - Never use CLI
9. **üî• ECONOMIC INTEGRATION IS CRITICAL** - All domains must integrate with PMP/PMC system
10. **Use Domain Events for cross-domain economic transactions**
11. **Shared Economy Kernel for read access, Events for write access**
12. **Always display economic balance in relevant UI components**
13. **üî• ALWAYS run security advisors after schema changes**

## MCP Tool Priority (CRITICAL)

### Supabase MCP Tools (Database Operations)

1. **`mcp_supabase_list_projects`** - Get project information
2. **`mcp_supabase_list_tables`** - Inspect current schema
3. **`mcp_supabase_apply_migration`** - Apply schema changes
4. **`mcp_supabase_execute_sql`** - Run queries and DML
5. **`mcp_supabase_get_advisors`** - Check security/performance
6. **`mcp_supabase_generate_typescript_types`** - Generate types

### GitHub MCP Tools (Project Management)

1. **`mcp_Github_get_repository`** - Repository information
2. **`mcp_Github_list_issues`** - View tasks and bugs
3. **`mcp_Github_create_issue`** - Create new tasks
4. **`mcp_Github_create_pull_request`** - Submit code for review
5. **`mcp_Github_get_file_contents`** - Read files from repo
6. **`mcp_Github_create_or_update_file`** - Modify repo files

**NEVER use:**

- Supabase CLI commands
- GitHub CLI commands (gh)
- Direct SQL file execution
- Manual schema management
- Manual GitHub web interface operations

## Dual MCP Workflow Integration

### Complete Development Cycle

1. **Issue Creation** ‚Üí `mcp_Github_create_issue` (Í≤ΩÏ†ú ÏãúÏä§ÌÖú Ïù¥Ïäà ÌÖúÌîåÎ¶ø ÏÇ¨Ïö©)
2. **Database Design** ‚Üí `mcp_supabase_apply_migration` (Ïä§ÌÇ§Îßà Î≥ÄÍ≤Ω)
3. **Code Implementation** ‚Üí `mcp_Github_create_or_update_file` (ÌååÏùº Í¥ÄÎ¶¨)
4. **Pull Request** ‚Üí `mcp_Github_create_pull_request` (ÏΩîÎìú Î¶¨Î∑∞)
5. **Security Check** ‚Üí `mcp_supabase_get_advisors` (Î≥¥Ïïà Í≤ÄÏ¶ù)
6. **Type Generation** ‚Üí `mcp_supabase_generate_typescript_types` (ÌÉÄÏûÖ ÎèôÍ∏∞Ìôî)

### Automated Quality Assurance Integration

- **GitHub MCP**: DDD ÏïÑÌÇ§ÌÖçÏ≤ò Ï§ÄÏàò, PowerShell Ìò∏ÌôòÏÑ± Í≤ÄÏ¶ù
- **Supabase MCP**: RLS Ï†ïÏ±Ö, ÏÑ±Îä• ÏµúÏ†ÅÌôî Í∂åÏû•ÏÇ¨Ìï≠
- **Economic System**: Agency Theory Î°úÏßÅ Í≤ÄÏ¶ù, PMP/PMC Î¨¥Í≤∞ÏÑ±

When in doubt, ask yourself: "Does this follow DDD principles, Clean Architecture rules, use DUAL MCP tools (Supabase + GitHub), AND properly integrate with the economic system?"
